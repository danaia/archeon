# @archeon {GLYPH_QUALIFIED_NAME}
# Generated by Archeon - Do not edit manually

from typing import Optional, List, Any
from datetime import datetime
from pydantic import BaseModel, Field, ConfigDict
from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorCollection
{IMPORTS}


# === API Schemas (Request/Response) ===

class {MODEL_NAME}Create(BaseModel):
    """Request schema for creating a {ENTITY}."""
{CREATE_FIELDS}


class {MODEL_NAME}Update(BaseModel):
    """Request schema for updating a {ENTITY}."""
{UPDATE_FIELDS}


class {MODEL_NAME}Response(BaseModel):
    """Response schema for {ENTITY}."""
    model_config = ConfigDict(from_attributes=True)
    
    id: str
{RESPONSE_FIELDS}
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class {MODEL_NAME}ListResponse(BaseModel):
    """Response schema for list of {ENTITY}s."""
    items: List[{MODEL_NAME}Response]
    total: int


# === Database Model ===

class {MODEL_NAME}:
    """MongoDB document model for {ENTITY}."""
    
    collection_name = "{COLLECTION_NAME}"
    
    def __init__(
        self,
{INIT_FIELDS}
        _id: Optional[ObjectId] = None,
        created_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
    ):
{FIELD_ASSIGNMENTS}
        self._id = _id
        self.created_at = created_at or datetime.utcnow()
        self.updated_at = updated_at
    
    def to_dict(self) -> dict:
        """Convert to dictionary for MongoDB."""
        return {
            "_id": self._id,
{TO_DICT_FIELDS}
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    def to_response(self) -> {MODEL_NAME}Response:
        """Convert to API response schema."""
        return {MODEL_NAME}Response(
            id=str(self._id),
{TO_RESPONSE_FIELDS}
            created_at=self.created_at,
            updated_at=self.updated_at,
        )
    
    @classmethod
    def from_dict(cls, data: dict) -> "{MODEL_NAME}":
        """Create instance from MongoDB document."""
        return cls(
{FROM_DICT_FIELDS}
            _id=data.get("_id"),
            created_at=data.get("created_at"),
            updated_at=data.get("updated_at"),
        )
    
    @classmethod
    def from_create(cls, data: {MODEL_NAME}Create) -> "{MODEL_NAME}":
        """Create instance from API request."""
        return cls(
{FROM_CREATE_FIELDS}
        )


# === Repository ===

class {MODEL_NAME}Repository:
    """Repository for {MODEL_NAME} database operations."""
    
    def __init__(self, collection: AsyncIOMotorCollection):
        self.collection = collection
    
    async def create(self, data: {MODEL_NAME}Create) -> {MODEL_NAME}Response:
        """Create a new {ENTITY}."""
        model = {MODEL_NAME}.from_create(data)
        result = await self.collection.insert_one(model.to_dict())
        model._id = result.inserted_id
        return model.to_response()
    
    async def find_by_id(self, id: str) -> Optional[{MODEL_NAME}Response]:
        """Find {ENTITY} by ID."""
        doc = await self.collection.find_one({"_id": ObjectId(id)})
        if not doc:
            return None
        return {MODEL_NAME}.from_dict(doc).to_response()
    
    async def find_many(
        self, 
        filter: dict = None, 
        skip: int = 0, 
        limit: int = 20
    ) -> {MODEL_NAME}ListResponse:
        """Find multiple {ENTITY}s."""
        query = filter or {}
        total = await self.collection.count_documents(query)
        cursor = self.collection.find(query).skip(skip).limit(limit)
        items = [{MODEL_NAME}.from_dict(doc).to_response() async for doc in cursor]
        return {MODEL_NAME}ListResponse(items=items, total=total)
    
    async def update(self, id: str, data: {MODEL_NAME}Update) -> Optional[{MODEL_NAME}Response]:
        """Update a {ENTITY}."""
        updates = data.model_dump(exclude_unset=True)
        updates["updated_at"] = datetime.utcnow()
        result = await self.collection.find_one_and_update(
            {"_id": ObjectId(id)},
            {"$set": updates},
            return_document=True
        )
        if not result:
            return None
        return {MODEL_NAME}.from_dict(result).to_response()
    
    async def delete(self, id: str) -> bool:
        """Delete a {ENTITY}."""
        result = await self.collection.delete_one({"_id": ObjectId(id)})
        return result.deleted_count > 0

{METHODS}
