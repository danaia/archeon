# Archeon Knowledge Graph
# Version: 3.0
# Project: Archeon

# ============================================================================
# ARCHITECTURE SHAPE SYSTEM
# ============================================================================
# Archeon uses JSON-based "shapes" (.shape.json) to define complete architectures.
# Each shape contains glyph snippets, directory structures, and configurations.
#
# SHAPE STRUCTURE:
# ```json
# {
#   "meta": { "id": "vue3-fastapi", "name": "Vue 3 + FastAPI", "version": "1.0" },
#   "stack": { "frontend": {...}, "backend": {...} },
#   "directories": { "frontend": {...}, "backend": {...} },
#   "glyphs": {
#     "CMP": { "layer": "frontend", "snippet": "...", "placeholders": {...} },
#     "STO": { "layer": "frontend", "snippet": "...", "placeholders": {...} },
#     "API": { "layer": "backend", "snippet": "...", "placeholders": {...} }
#   },
#   "config": { "tailwind": {...}, "themeStore": {...} },
#   "dependencies": { "frontend": {...}, "backend": {...} }
# }
# ```
#
# CLI USAGE:
# - `arc shapes` - List available architecture shapes
# - `arc init --arch vue3-fastapi` - Initialize with specific shape
# - `arc init -f vue3 -b fastapi` - Auto-maps to vue3-fastapi shape
#
# SHAPE INSTALLATION:
# When you run `arc init --arch <shape-id>`, Archeon will:
# 1. Create project structure (client/, server/, archeon/)
# 2. Copy shape file to archeon/<shape-id>.shape.json
# 3. Add a default NED:system.ready glyph to ARCHEON.arcon
# 4. This default glyph signals the system is ready for AI-driven development
# 5. The glyph will be automatically replaced as you build real features
#
# DEFAULT READY GLYPH (auto-generated):
# ```
# @v1 NED:system.ready => OUT:architecture.installed
# ```
# This placeholder chain indicates the architecture is installed and ready.
# Start chatting with your AI to create the first real feature chain!
#
# SHAPE LOCATIONS:
# - Built-in: archeon/architectures/*.shape.json
# - Project: archeon/<shape-id>.shape.json (copied on init)
#
# EXTENDING SHAPES:
# Create new .shape.json files in archeon/architectures/ with unique "meta.id"
# ============================================================================

# ============================================================================
# SEMANTIC SECTION SYSTEM
# ============================================================================
# Archeon uses comment-based semantic bracketing for AI-native code navigation.
#
# CORE PRINCIPLE:
# The code describes itself using semantic comment brackets.
# The index records *what sections exist*, not where they are.
# The LLM uses section labels as attention anchors.
#
# FILE HEADER FORMAT (required at top of every generated file):
# ```
# // @archeon:file
# // @glyph CMP:LoginForm
# // @intent User login input and submission
# // @chain @v1 NED:login => CMP:LoginForm => STO:Auth => API:POST/auth
# ```
#
# SECTION FORMAT (inside files):
# ```
# // @archeon:section <snake_case_label>
# // <1-sentence intent>
# <code>
# // @archeon:endsection
# ```
#
# SECTION RULES:
# - Sections MUST NOT nest
# - Sections MUST be contiguous
# - Section labels are STABLE identifiers
# - Section comments are NEVER deleted without updating intent
# - Code edits must occur INSIDE existing sections unless creating new one
#
# STANDARD SECTIONS BY GLYPH TYPE:
# CMP: imports, props_and_state, handlers, render, styles
# STO: imports, state, actions, selectors
# API: imports, models, endpoint, helpers
# FNC: imports, implementation, helpers
# EVT: imports, channels, handlers
# MDL: imports, schema, methods, indexes
#
# INDEX STRUCTURE (archeon/ARCHEON.index.json):
# ```json
# {
#   "CMP:LoginForm": {
#     "file": "components/LoginForm.vue",
#     "intent": "User login input and submission",
#     "chain": "@v1",
#     "sections": ["props_and_state", "handlers", "render"]
#   }
# }
# ```
# ============================================================================

# ============================================================================
# AI INTEGRATION INSTRUCTIONS
# ============================================================================
# When the IDE AI (Copilot, Claude, etc.) generates Archeon-compatible files:
#
# 1. ALWAYS include the @archeon:file header with @glyph, @intent, @chain
# 2. ALWAYS wrap code in @archeon:section / @archeon:endsection blocks
# 3. ALWAYS update the index after creating/modifying files
#
# TO UPDATE INDEX (run in terminal after generating files):
# ```bash
# python -m archeon index build
# ```
#
# OR in Python:
# ```python
# from archeon.orchestrator.IDX_index import build_index
# build_index(".")
# ```
#
# The AI should treat index updates as part of code generation - not optional.
# ============================================================================

# === ORCHESTRATOR LAYER (Deterministic) ===
ORC:main :: PRS:glyph :: PRS:intent :: VAL:chain :: VAL:boundary :: VAL:version :: SPW:agent :: TST:e2e :: TST:error
GRF:domain :: ORC:main

# === SHAPE LOADER LAYER ===
# SHP loads architecture shapes from JSON files
# Provides glyph snippets, directory mappings, and configurations
SHP:loader :: ORC:main
SHP:loader :: SPW:agent

# === CONTEXT MANAGEMENT (Small Model Optimization) ===
# CTX manages context budgets to keep payloads within 60K tokens for 30B models
# MIC executes single-glyph operations with minimal context
CTX:budget :: CTX:projection :: ORC:main
CTX:projection :: GRF:domain
MIC:executor :: CTX:projection :: SPW:agent

# === SECTION SCANNER (Index Builder) ===
# SCN scans files for @archeon:section markers and rebuilds index
# IDX stores the semantic affordance map (glyph -> file -> sections)
SCN:scanner :: IDX:index :: GRF:domain
SCN:scanner :: PRS:glyph
IDX:index :: CTX:projection

# === DESIGN TOKEN LAYER ===
# TKN transforms DTCG design tokens into CSS/Tailwind/JS outputs
# Single source of truth for all design system values
TKN:transformer :: CSS:variables :: TW:config :: JS:constants
TKN:semantic :: TKN:transformer

# === THEME SYSTEM ===
# Two-layer theme architecture:
# 1. Mode (light/dark/system) - controls brightness/contrast (standard)
# 2. Color Theme - controls primary palette (PROJECT-SPECIFIC)
#
# IMPORTANT: Color themes (blue/purple/green in templates) are EXAMPLES.
# Each project defines its own themes based on its design system.
# The theme store constants must be customized per project.
#
# STO:Theme manages both layers and persists to localStorage
# Color themes work via CSS class swapping on document root
# Components use --color-primary-* variables which resolve to active theme
#
# Flow: design-tokens.json -> theme-presets.css -> STO:Theme -> CSS variables -> components
STO:Theme ~> CMP:*
TKN:transformer :: STO:Theme

# === AGENT CHAINS (Versioned) ===
# Add chains below using: archeon parse "<chain>"

# IDE Integration - AI rules generation for various IDEs
@v1 NED:ide.rules => FNC:cli.init => FNC:cli.aiSetup => OUT:rules.generated
    -> ERR:rules.templateMissing
# Supported IDEs: copilot, cursor, windsurf, cline, aider, vscode, antigravity
